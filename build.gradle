buildscript {
    repositories {
        mavenCentral()
        jcenter()
        maven { url = 'https://maven.minecraftforge.net/' }
        maven { url = 'https://repo.spongepowered.org/maven/' }
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:4.+'
        classpath 'org.spongepowered:mixingradle:0.7-SNAPSHOT'
        classpath 'com.github.jengelman.gradle.plugins:shadow:6.1.0'
        classpath "de.undercouch:gradle-download-task:5.1.0"
    }
}

plugins {
    id 'org.jetbrains.kotlin.jvm' version "$kotlinVersion"
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'eclipse'
apply plugin: 'maven-publish'
apply plugin: 'org.spongepowered.mixin'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: "de.undercouch.download"

version project.modVersion
group project.modGroup

compileJava {
    sourceCompatibility = targetCompatibility = '1.8'
    options.encoding = 'UTF-8'
}

compileKotlin.kotlinOptions {
    freeCompilerArgs += '-Xlambdas=indy'
    freeCompilerArgs += '-opt-in=kotlin.RequiresOptIn'
    freeCompilerArgs += '-opt-in=kotlin.contracts.ExperimentalContracts'
}

repositories {
    mavenCentral()
    maven { url = 'https://repo.spongepowered.org/maven/' }
    maven { url = 'https://impactdevelopment.github.io/maven/' }
    maven { url = 'https://jitpack.io' }
}

minecraft {
    mappings channel: "$mappingsChannel", version: "$mappingsVersion"

    runs {
        client {
            workingDirectory project.file('run')

            property 'fml.coreMods.load', 'com.lambda.client.LambdaCoreMod'
            property 'mixin.env.disableRefMap', 'true' // Disable refmap so we don't get trolled by Baritone

            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            property 'forge.logging.console.level', 'debug'
        }
    }
}

configurations {
    jarLibs
    // Force choosing the correct nightly build because Mac OS chooses an invalid one
    all {
        resolutionStrategy {
            force 'org.lwjgl.lwjgl:lwjgl-platform:2.9.4-nightly-20150209'
        }
    }
}

dependencies {
    // Forge
    minecraft "net.minecraftforge:forge:$minecraftVersion-$forgeVersion"

    jarLibs('org.spongepowered:mixin:0.8.5') {
        exclude module: 'commons-io'
        exclude module: 'gson'
        exclude module: 'guava'
    }

    // Hacky way to get mixin work
    annotationProcessor('org.spongepowered:mixin:0.8.5:processor') {
        exclude module: 'gson'
    }

    // Not the latest Reflections because it breaks Future compatibility :/
    //noinspection GradlePackageUpdate
    jarLibs 'org.reflections:reflections:0.9.12'

    jarLibs("org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion") {
        exclude module: 'kotlin-stdlib-common'
        exclude module: 'annotations'
    }

    jarLibs("org.jetbrains.kotlin:kotlin-reflect:$kotlinVersion") {
        exclude module: 'kotlin-stdlib'
    }

    jarLibs("org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlinxCoroutinesVersion") {
        exclude module: 'kotlin-stdlib-jdk8'
        exclude module: 'kotlin-stdlib-common'
    }

    jarLibs 'com.github.cbyrneee:DiscordIPC:e18542f600'

    // Add them back to compileOnly (provided)
    compileOnly "org.jetbrains.kotlin:kotlin-stdlib-common:$kotlinVersion"
    compileOnly 'org.jetbrains:annotations:23.0.0'

    // This Baritone will NOT be included in the jar
    implementation 'com.github.cabaletta:baritone:1.2.14'

    // This Baritone WILL be included in the jar
    jarLibs 'cabaletta:baritone-api:1.2'

    // Add everything in jarLibs to implementation (compile)
    implementation configurations.jarLibs
}

sourceSets {
    schematica_api {
        compileClasspath += main.compileClasspath
    }

    main {
        compileClasspath += schematica_api.output
    }
}

private static java.nio.file.Path getResourceOutput(SourceSet sourceSet) {
    return sourceSet.getOutput().getResourcesDir().toPath();
}

task downloadBuildTools(type: Download) {
    src ([
            'https://ziglang.org/download/0.9.1/zig-windows-x86_64-0.9.1.zip',
            'https://github.com/Kitware/CMake/releases/download/v3.24.0-rc5/cmake-3.24.0-rc5-windows-x86_64.zip',
            'https://github.com/ninja-build/ninja/releases/download/v1.11.0/ninja-win.zip'
    ])
    dest new File(project.getBuildDir(), "downloadBuildTools")
    overwrite false
}

task unpackBuildTools(dependsOn: downloadBuildTools, type: Copy) {
    from zipTree(new File(downloadBuildTools.dest, 'cmake-3.24.0-rc5-windows-x86_64.zip'))
    from zipTree(new File(downloadBuildTools.dest, 'ninja-win.zip'))
    from zipTree(new File(downloadBuildTools.dest, 'zig-windows-x86_64-0.9.1.zip'))

    into new File(project.getBuildDir(), "unpackedBuildTools")

    doLast { t ->
        def base = t.outputs.files.getSingleFile().toPath()
        Files.write(base.resolve("zigcc.bat"), ("@echo off\n" + getWintardZig().absolutePath + " \"cc\" %*").getBytes())
        Files.write(base.resolve("zigcpp.bat"), ("@echo off\n" + getWintardZig().absolutePath + " \"c++\" %*").getBytes())
    }
}

def getWintardCmake() {
    return new File(unpackBuildTools.outputs.files.getSingleFile(), "cmake-3.24.0-rc5-windows-x86_64/bin/cmake.exe")
}

def getWintardNinja() {
    return new File(unpackBuildTools.outputs.files.getSingleFile(), "ninja.exe")
}

def getWintardZig() {
    return new File(unpackBuildTools.outputs.files.getSingleFile(), "zig-windows-x86_64-0.9.1/zig.exe")
}

def getWintardZigCC() {
    return new File(unpackBuildTools.outputs.files.getSingleFile(), "zigcc.bat")
}

def getWintardZigCXX() {
    return new File(unpackBuildTools.outputs.files.getSingleFile(), "zigcpp.bat")
}

final String compileLibraryOutput = 'compilePathfinderLibrary';

import org.apache.tools.ant.taskdefs.condition.Os

import java.nio.file.Files

task cmakePathfinderLibrary(type: Exec) {
    final File outputDir = new File(project.getBuildDir(), compileLibraryOutput)
    outputDir.mkdirs()

    workingDir outputDir
    final File sourceDir = new File(getProjectDir(), 'nether-pathfinder')

    String cmakeExe
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        dependsOn unpackBuildTools
        cmakeExe = getWintardCmake().toString()
    } else {
        cmakeExe = 'cmake' // $PATH
    }

    def cmakeArgs = [
            cmakeExe, sourceDir.toString(),
            '-G', 'Ninja'
    ]
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        cmakeArgs.addAll([
                '-DCMAKE_MAKE_PROGRAM=' + getWintardNinja().toString(),
                '-DCMAKE_C_COMPILER=' + getWintardZigCC().toString().replace('\\', '/'),
                '-DCMAKE_CXX_COMPILER=' + getWintardZigCXX().toString().replace('\\', '/')
        ])
    } else {
        cmakeArgs.add("-DCMAKE_CXX_COMPILER=clang++")
        cmakeArgs.add("-DCMAKE_C_COMPILER=clang") // not used
        // abseil doesnt work on windows because of a pthread issue, might possibly be already fixed upstream
        cmakeArgs.add('-DUSE_ABSEIL=True')
    }
    cmakeArgs.addAll([
            '-DSHARED_LIBRARY=True',
            '-DCMAKE_BUILD_TYPE=Release'
    ])
    commandLine cmakeArgs
}

task makePathfinderLibrary(type: Exec) {
    dependsOn cmakePathfinderLibrary

    final File outputDir = new File(project.getBuildDir(), compileLibraryOutput)

    workingDir outputDir
    String ninjaExe;
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        ninjaExe = getWintardNinja()
    } else {
        ninjaExe = 'ninja' // $PATH
    }
    commandLine ninjaExe, '-j', Runtime.getRuntime().availableProcessors()
}

task moveLibraryToResources(type: Copy) {
    dependsOn makePathfinderLibrary

    from (new File(project.getBuildDir(), compileLibraryOutput)) {
        include '*.dll'
        include '*.so'
        include '*.dylib'
    }
    into getResourceOutput(sourceSets.main).resolve('native')
    // TODO: also rename?
}

jar.dependsOn(moveLibraryToResources)

mixin {
    defaultObfuscationEnv 'searge'
    sourceSets {
        main {
            ext.refMap = 'mixins.lambda.refmap.json'
        }
    }
}

processResources {
    exclude '**/rawimagefiles'

    from(sourceSets.main.resources.srcDirs) {
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
        include 'mcmod.info'
        expand version: version, 'mcversion': minecraftVersion
    }
}

task buildApiSource(type: Jar) { // Generate sources
    group 'build'
    description 'Assemble API library source archive'

    archiveClassifier.set 'api-source'
    from sourceSets.main.allSource
}

task buildApi(type: Jar) {
    group 'build'
    description 'Assemble API library archive'

    archiveClassifier.set 'api'
    from sourceSets.main.output
}

task buildAll {
    group 'build'
    description 'Assemble all jars'

    dependsOn 'buildApi'
    dependsOn 'buildApiSource'
    dependsOn 'build'
}

shadowJar {
    // Don't put baritone mixin here please c:
    manifest.attributes(
            'Manifest-Version': 1.0,
            'MixinConfigs': 'mixins.lambda.json',
            'TweakClass': 'org.spongepowered.asm.launch.MixinTweaker',
            'FMLCorePluginContainsFMLMod': 'true',
            'FMLCorePlugin': 'com.lambda.client.LambdaCoreMod',
            'ForceLoadAsMod': 'true'
    )

    archiveClassifier.set('')
    exclude '**/module-info.class',
            'DebugProbesKt.bin',
            'META-INF/proguard/**',
            'META-INF/versions/**',
            'META-INF/**.RSA',
            'META-INF/com.android.tools/**',
            'META-INF/*.kotlin_module',
            'kotlin/**/*.kotlin_metadata',
            'kotlin/**/*.kotlin_builtins',
            'META-INF/*.version'
    configurations = [project.configurations.jarLibs]
    relocate 'kotlin', 'com.lambda.shadow.kotlin'
    relocate 'kotlinx', 'com.lambda.shadow.kotlinx'
    finalizedBy 'reobfShadowJar'
}

reobf {
    shadowJar {}
    jar {
        enabled = false
    }
}

artifacts {
    shadowJar
}
jar.finalizedBy('reobfJar')

